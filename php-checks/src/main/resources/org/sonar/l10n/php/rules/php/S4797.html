<p>处理文件是安全敏感的。它在过去导致了以下漏洞：</p>
<ul>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0358">CVE-2018-0358</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7560">CVE-2017-7560</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-4015">CVE-2005-4015</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-3835">CVE-2018-3835</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-8008">CVE-2018-8008</a> </li>
  <li> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2320">CVE-2010-2320</a> </li>
</ul>
<p>对文件系统的任何访问都可能造成漏洞。暴露文件的内容、路径甚至是文件的存在与否都是危险的。如果不确保文件的权限和内容是安全的、受控制的，那么创建或编写文件也是非常危险的。
使用文件路径或读取文件内容时必须始终保持谨慎，因为它们可能被篡改。</p>
<p>文件系统是一种很容易耗尽的资源。打开太多的文件将耗尽所有的文件描述符，从而阻止其他软件打开文件。填充存储空间还可以防止发生任何额外的写操作。</p>
<p>这条规则对<a href="http://php.net/manual/en/ref.filesystem.php">文件系统函数</a> 提出了一个问题，这些函数对安全性有很大的影响，并且常常受到注入的影响。目标是指导手动安全代码检查。</p>
<h2>检查是否有下列问题：</h2>
<ul>
  <li> 正在使用的文件或目录路径来自用户输入，或者可能已被篡改。</li>
  <li> 代码向未授权的人公开文件或目录的存在。给用户的任何提示都可能是危险的。如果文件/目录不存在，则显示错误，或者如果文件/目录存在，但用户无法执行操作，则返回“未授权”错误，这样就可以提供信息。</li>
  <li> 代码向未授权的人公开文件和/或目录的路径，例如通过列出目录的内容并显示输出。</li>
  <li> 可能使用错误的权限创建文件或目录。</li>
  <li> 未验证的用户输入被写入文件。</li>
  <li> 读取文件并在未经验证的情况下使用其内容。</li>
  <li> 读取文件并将其内容公开给未经授权的人员。</li>
  <li> 每次用户执行操作时，都会打开、创建或写入文件。</li>
  <li> 文件在执行子进程之前是打开的，而不是关闭的。只有在您的编程语言(例如:C、c++)中继承了文件描述符时，这才是危险的。</li>
</ul>
<p>如果对其中任何一个问题的回答是肯定的，那么就有风险。</p>
<h2>推荐的安全编码实践</h2>
<p>尽可能避免使用用户或其他不可信源提供的路径。如果需要这样做，请检查路径是否引用未经授权的目录或文件。有关如何测试目录遍历，请参阅 <a href="https://www.owasp.org/index.php/Testing_Directory_traversal/file_include_(OTG-AUTHZ-001)">OWASP建议</a> 。注意，路径长度也应该进行验证。</p>
<p>不应该公开任何文件和目录名。它们可能包含敏感信息。这意味着用户不能列出未授权目录的内容。</p>
<p>确保没有攻击者能够测试敏感文件的存在与否。知道存在特定的文件可以暴露漏洞，或者至少暴露文件和目录名。</p>
<p>应该使用受限制的权限和所有权创建文件和目录。只有经过授权的用户和应用程序才能访问这些文件，并且它们应该具有尽可能少的权限。仅仅修改文件的权限是不够的。从一开始就应该限制权限。</p>
<p>将用户输入写入文件时应谨慎。如果不控制写入的数据量，它可以填充存储空间。它还可以编写危险的数据，这些数据稍后将被应用程序使用或返回给其他用户。这就是为什么在编写之前应该验证用户输入。</p>
<p>读取文件可能会导致其他漏洞。任何文件都可能被攻击者修改。因此，应该对文件内容执行与任何用户输入相同的验证。</p>
<p>一旦文件被读取，它的内容应该只向授权用户公开。</p>
<p>为应用程序同时访问或由于用户操作而创建的文件数量添加限制。通过打开太多的文件，从而耗尽可用的文件描述符，或者用新文件填充文件系统，可以执行拒绝服务攻击。通过尽快关闭文件来释放文件描述符。</p>
<p>我们还建议使用工具监视系统，并在资源几乎耗尽时发出警报。</p>
<p>不允许不受信任的代码访问文件系统。对于某些编程语言，子进程可以访问父进程在创建子进程之前打开的文件描述符。当子进程没有访问文件的权限，但仍然能够通过继承的文件描述符修改文件时，这将创建一个漏洞。
检查语言文档是否存在“文件描述符泄漏”，或者使用 <code>O_CLOEXEC</code>，<code>FD_CLOEXEC</code>，或 <code>bInheritHandles</code>。文件描述符可以用以下语言继承：
C，C++，C#，Objective-C，Swift，Go (but disabled by default)，一些JVM版本，用Nodejs编写Javascript 和 TypeScript，一些PHP版本，Python，Ruby，Rust，VB6 和VB.NET。</p>
<h2>可疑的代码示例</h2>
<pre>
function handle_file($filename, $directory, $group, $data, $mode, $flags, $use_include_path, $pattern, $recursive, $context)
{
    file_put_contents($filename, $data, $flags); // 可疑的
    copy($filename, $filename); // 可疑的
    tmpfile(); // 可疑的
    parse_ini_file($filename); // 可疑的

    // 仅当 $filename 或 $directory 没有硬编码时，以下调用才会引发问题
    move_uploaded_file($filename, $filename); // 可疑的
    rmdir($directory); // 可疑的
    unlink($filename); // 可疑的

    move_uploaded_file("mypath1", "mypath2"); // 可疑的
    rmdir("dir1"); // 可疑的
    unlink("dir2"); // 可疑的

    // 下面的函数也可以用来执行网络请求(http，套接字（socket），ftp等)
    // 在某些情况下，他们不会提出问题，见下文。
    file_get_contents($filename, $use_include_path); // 可疑的
    file($filename, $flags); // 可疑的
    fopen($filename, $mode, $use_include_path); // 可疑的
    readfile($filename, $use_include_path); // 可疑的

    // 如果从带前缀的包装器(如'rar://'，'zlib://'，'bzip2://'，'zip://'，'compress.zlib://'，'compress.bzip2://'，'glob://'，'ogg://') 清除的源路径仍然包含'://' 而不以'file://'开头，则不会引发任何问题。
    file_get_contents("zip://http://example.com/file.zip" $use_include_path); // 合规的
    file("http://example.com", $flags); // 合规的
    fopen("http://example.com", $mode, $use_include_path); // 合规的
    readfile("http://example.com", $use_include_path); // 合规的

    // 如果给定上下文，则不会产生任何问题，因为它很可能不是文件系统访问。
    // 注意，这将创建一些带有“zip”环境的漏报。
    file_get_contents($filename, $use_include_path, $context); // 合规的
    file($filename, $flags, $context); // 合规的
    fopen($filename, $mode, $use_include_path, $context); // 合规的
    readfile($filename, $use_include_path, $context); // 合规的
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/732">MITRE, CWE-732</a> - Incorrect Permission Assignment for Critical Resource </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/73">MITRE, CWE-73</a> - External Control of File Name or Path </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/20">MITRE, CWE-20</a> - Improper Input Validation </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/22">MITRE, CWE-22</a> - Improper Limitation of a Pathname to a Restricted Directory ('Path
  Traversal') </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/400">MITRE, CWE-400</a> - Uncontrolled Resource Consumption ('Resource Exhaustion') </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/538">MITRE, CWE-538</a> - File and Directory Information Exposure </li>
  <li> <a href="http://cwe.mitre.org/data/definitions/403">MITRE, CWE-403</a> - Exposure of File Descriptor to Unintended Control Sphere ('File
  Descriptor Leak') </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/g4HWAw">CERT, FIO01-J.</a> - Create files with appropriate access permissions </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/KQU">CERT, FIO06-C.</a> - Create files with appropriate access permissions </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/display/c/FIO22-C.+Close+files+before+spawning+processes">CERT, FIO22-C.</a> Close files before
  spawning processes </li>
  <li> OWASP Top 10 2017 Category A1 - Injection </li>
  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
  <li> <a href="https://www.sans.org/top25-software-errors/#cat2">SANS Top 25</a> - Risky Resource Management </li>
  <li> <a href="https://www.sans.org/top25-software-errors/#cat3">SANS Top 25</a> - Porous Defenses </li>
</ul>

