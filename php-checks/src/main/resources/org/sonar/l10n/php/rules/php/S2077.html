<h2>Why is this an issue?</h2>
<p>Using dynamic SQL queries that concatenate user input directly into the query string can lead to SQL injection vulnerabilities. Attackers can
manipulate the input to alter the SQL queryâ€™s structure, potentially gaining unauthorized access to or manipulating the database.</p>
<h3>Exceptions</h3>
<p>No issue will be raised if one of the functions is called with hard-coded string (no concatenation) and this string does not contain a "$"
sign.</p>
<pre>
$result = mysql_query("SELECT * FROM myTable WHERE id = 42") or die('Query failed: ' . mysql_error());  // Compliant
</pre>
<p>The current implementation does not follow variables. It will only detect SQL queries which are concatenated or contain a <code>$</code> sign
directly in the function call.</p>
<pre>
$query = "SELECT * FROM myTable WHERE id = " . $id;
$result = mysql_query($query);  // No issue will be raised even if it is Sensitive
</pre>
<h2>How to fix it</h2>
<p>To prevent SQL injection vulnerabilities, use prepared statements with parameterized queries. This approach separates the SQL code from the data,
ensuring that user input is treated as data only and not executable code.</p>
<h3>Code Examples</h3>
<h4>Noncompliant Code Example</h4>
<pre data-diff-id="1" data-diff-type="noncompliant">
$id = $_GET['id'];
mysql_connect('localhost', $username, $password) or die('Could not connect: ' . mysql_error());
mysql_select_db('myDatabase') or die('Could not select database');

$result = mysql_query("SELECT * FROM myTable WHERE id = " . $id);  // Noncompliant, could be susceptible to SQL injection

while ($row = mysql_fetch_object($result)) {
    echo $row-&gt;name;
}
</pre>
<h4>Compliant Solution</h4>
<pre data-diff-id="1" data-diff-type="compliant">
$id = $_GET['id'];
try {
    $conn = new PDO('mysql:host=localhost;dbname=myDatabase', $username, $password);
    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

    $stmt = $conn-&gt;prepare('SELECT * FROM myTable WHERE id = :id');
    $stmt-&gt;execute(array('id' =&gt; $id));

    while($row = $stmt-&gt;fetch(PDO::FETCH_OBJ)) {
        echo $row-&gt;name;
    }
} catch(PDOException $e) {
    echo 'ERROR: ' . $e-&gt;getMessage();
}
</pre>
<h2>Resources</h2>
<ul>
  <li> OWASP - <a href="https://owasp.org/Top10/A03_2021-Injection/">Top 10 2021 Category A3 - Injection</a> </li>
  <li> OWASP - <a href="https://owasp.org/www-project-top-ten/2017/A1_2017-Injection">Top 10 2017 Category A1 - Injection</a> </li>
  <li> CWE - <a href="https://cwe.mitre.org/data/definitions/20">CWE-20 - Improper Input Validation</a> </li>
  <li> CWE - <a href="https://cwe.mitre.org/data/definitions/89">CWE-89 - Improper Neutralization of Special Elements used in an SQL Command</a> </li>
  <li> Derived from FindSecBugs rules <a href="https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_JPA">Potential SQL/JPQL Injection
  (JPA)</a>, <a href="https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_JDO">Potential SQL/JDOQL Injection (JDO)</a>, <a
  href="https://h3xstream.github.io/find-sec-bugs/bugs.htm#SQL_INJECTION_HIBERNATE">Potential SQL/HQL Injection (Hibernate)</a> </li>
</ul>

